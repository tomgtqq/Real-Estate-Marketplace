// define a variable to import the <Verifier> or <renamedVerifier> solidity contract generated by Zokrates
var Verifier = artifacts.require('Verifier');
const truffleAssert = require('truffle-assertions');
const proof_json= require("../../zokrates/code/square/proof.json");

// - use the contents from proof.json generated from zokrates steps
const proofData = {
    "proof": {
            "A": [web3.utils.toBN(proof_json.proof.A[0]).toString(), web3.utils.toBN(proof_json.proof.A[1]).toString()],
            "A_p": [web3.utils.toBN(proof_json.proof.A_p[0]).toString(), web3.utils.toBN(proof_json.proof.A_p[1]).toString()],
            "B": [[web3.utils.toBN(proof_json.proof.B[0][0]).toString(), web3.utils.toBN(proof_json.proof.B[0][1]).toString()],
                [web3.utils.toBN(proof_json.proof.B[1][0]).toString(), web3.utils.toBN(proof_json.proof.B[1][1]).toString()]
            ],
            "B_p": [web3.utils.toBN(proof_json.proof.B_p[0]).toString(), web3.utils.toBN(proof_json.proof.B_p[1]).toString()],
            "C": [web3.utils.toBN(proof_json.proof.C[0]).toString(), web3.utils.toBN(proof_json.proof.C[1]).toString()],
            "C_p": [web3.utils.toBN(proof_json.proof.C_p[0]).toString(), web3.utils.toBN(proof_json.proof.C_p[1]).toString()],
            "H": [web3.utils.toBN(proof_json.proof.H[0]).toString(), web3.utils.toBN(proof_json.proof.H[1]).toString()],
            "K": [web3.utils.toBN(proof_json.proof.K[0]).toString(), web3.utils.toBN(proof_json.proof.K[1]).toString()]
        },
        "input": proof_json.input
    }

contract('Verifier', accounts =>{
    before(async() => {
        this.verifier = await Verifier.new({from: accounts[0]});
    });

    // Test verification with correct proof 
    it('should verify with correct proof', async() => {
        let transferTx = await this.verifier.verifyTx(
            proofData.proof.A,
            proofData.proof.A_p,
            proofData.proof.B,
            proofData.proof.B_p,
            proofData.proof.C,
            proofData.proof.C_p,
            proofData.proof.H,
            proofData.proof.K,
            proofData.input,
            {from: accounts[0]}
        );
        truffleAssert.eventEmitted(transferTx, 'Verified');
    })
        
    // Test verification with incorrect proof
    it('should not verify with incorrect proof', async() => {
        let isVerified = await this.verifier.verifyTx.call(
            proofData.proof.A,
            proofData.proof.A_p,
            proofData.proof.B,
            proofData.proof.B_p,
            proofData.proof.C,
            proofData.proof.C_p,
            proofData.proof.H,
            proofData.proof.K,
            [18,2], //  proofData.input  ->  "input":[9,1]
            {from: accounts[0]}
        );
        assert.equal(isVerified, false, "Verified with incorrect proof");
    })
})


